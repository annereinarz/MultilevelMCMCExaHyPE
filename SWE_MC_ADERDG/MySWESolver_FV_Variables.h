// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __MySWESolver_FV_Variables_CLASS_HEADER__
#define __MySWESolver_FV_Variables_CLASS_HEADER__

#include "AbstractMySWESolver_FV.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

/**
 * Generic information about the variable string as it was declared in the
 * specification file
 **/
struct SWE::AbstractMySWESolver_FV::VariableMetrics {
  static constexpr int numDistinctVariables = 4;
  static constexpr int SizeVariables  = 4; 
  static constexpr int SizeParameters = 0;
  static constexpr int Size           = 4+0;
  static constexpr int Dimensions     = DIMENSIONS;
};

/**
 * Positions of fields in the vector of unkonwns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation or create 
 * an instance of this class.
 **/
class SWE::AbstractMySWESolver_FV::VariableShortcuts : public SWE::AbstractMySWESolver_FV::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  const int _Q[numDistinctVariables + 1] = { 0,1,2,3 };

  const int h = 0;
  const int hu = 1;
  const int hv = 2;
  const int b = 3;

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableShortcuts

/**
 * Lengths (multplicities) of each field inside the unknown vector Q.
 * For instance, 0 means "scalar field" while any value >0 may mean a vector field or
 * even a "linearized" tensor field
 **/
class SWE::AbstractMySWESolver_FV::VariableMultiplicities : public SWE::AbstractMySWESolver_FV::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
 
  const int _Q[numDistinctVariables] = { 1,1,1,1 };

  const int h = 1;
  const int hu = 1;
  const int hv = 1;
  const int b = 1;

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableMultiplicities

/**
 * Variable names as strings as given in the toolkit.
 * 
 * These names might want to be used for plotting, output, etc.
 *
 **/
class SWE::AbstractMySWESolver_FV::VariableNames : public SWE::AbstractMySWESolver_FV::VariableMetrics {
public:
  char const *_Q[numDistinctVariables + 1] = { "h","hu","hv","b" };

  const char* h = "h";
  const char* hu = "hu";
  const char* hv = "hv";
  const char* b = "b";

  const char* const* asArray() const { return _Q; } // type: whatever
  const char* operator [] (int index) const { return _Q[index]; }
  const char* operator () (int index) const { return _Q[index]; }
}; // end of VariableNames

/**
 * Positions of fields in the vector of unknowns,
 * available as namespace constants.
 * 
 * You can use this namespace similar to the class "VariableShortcuts"
 * but you don't need an object, ie. your notation can get slimmer.
 * 
 * Usage is like:
 * 
 *    void somewhere() {
 *       using namespace SWE::MySWESolver_FV_Variables::shortcuts;
 *       Q[foo] = 17;
 *    }
 *
 * instead of
 * 
 *    void somewhere() {
 *       SWE::AbstractMySWESolver_FV::VariableNames q;
 *       Q[q.foo] = 17;
 *    }
 *
 **/
namespace SWE {
  namespace MySWESolver_FV_Variables {
    namespace shortcuts {
      constexpr int h = 0;
      constexpr int hu = 1;
      constexpr int hv = 2;
      constexpr int b = 3;
    } // namespace shortcuts
    namespace names {
      constexpr char h[] = "h"; 
      constexpr char hu[] = "hu"; 
      constexpr char hv[] = "hv"; 
      constexpr char b[] = "b"; 
    } // namespace names
  } // end of namespace SWE::MySWESolver_FV_Variables 
} // end of namespace SWE

/*
 * Another class idea:
 * 
 * class ....::VariablePointers {
 *   private:   double* Q;
 *   public:
 *      double &varfoo;
 *      double &varbar;
 *      VariablePointers(double* const Q) : varfoo(Q[0]), bar(Q[1]), ... {}
 * }
 * 
 * Advantages: Use as positions in Q.
 *
 */


class SWE::AbstractMySWESolver_FV::ReadOnlyVariables : public SWE::AbstractMySWESolver_FV::VariableMetrics {
  private:
    const double* const _Q;
  public:
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* data() const {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // getter and setter for h
    double h() const {return _Q[0];}
        
    // getter and setter for hu
    double hu() const {return _Q[1];}
        
    // getter and setter for hv
    double hv() const {return _Q[2];}
        
    // getter and setter for b
    double b() const {return _Q[3];}
        
}; // end of ReadOnlyVariables


class SWE::AbstractMySWESolver_FV::Variables : public SWE::AbstractMySWESolver_FV::VariableMetrics{
  private:
    double* const _Q;
  public:
    static constexpr int SizeVariables  = 4;
    static constexpr int SizeParameters = 0;
    static constexpr int Size           = 4+0;
  
    Variables(double* const Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // getter and setter for h
    double h() const {return _Q[0];}
    double& h() {return _Q[0];}
    
    // getter and setter for hu
    double hu() const {return _Q[1];}
    double& hu() {return _Q[1];}
    
    // getter and setter for hv
    double hv() const {return _Q[2];}
    double& hv() {return _Q[2];}
    
    // getter and setter for b
    double b() const {return _Q[3];}
    double& b() {return _Q[3];}
    
}; // end of Variables


class SWE::AbstractMySWESolver_FV::Fluxes : public SWE::AbstractMySWESolver_FV::VariableMetrics {
  private:
    double** const _F;
  public:
    Fluxes(double** const F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }


    // getters for h
    double h(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0];
    }
    tarch::la::Vector<DIMENSIONS,double> h() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0],_F[1][0]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0],_F[1][0],_F[2][0]);
      #endif
      return values;
    }
    // setters for h
    double& h(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0];
    }

    void h(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][0] = values[0];
      _F[1][0] = values[1];
      #if DIMENSIONS==3
      _F[2][0] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void h(const tarch::la::Vector<3,double>& values) {
      _F[0][0] = values[0];
      _F[1][0] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void h(double v0,double v1,double v2) {
      _F[0][0] = v0;
      _F[1][0] = v1;
      #if DIMENSIONS==3
      _F[2][0] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void h(double v0,double v1) {
      _F[0][0] = v0;
      _F[1][0] = v1;
    }
    #endif
    // getters for hu
    double hu(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][1];
    }
    tarch::la::Vector<DIMENSIONS,double> hu() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][1],_F[1][1]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][1],_F[1][1],_F[2][1]);
      #endif
      return values;
    }
    // setters for hu
    double& hu(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][1];
    }

    void hu(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][1] = values[0];
      _F[1][1] = values[1];
      #if DIMENSIONS==3
      _F[2][1] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void hu(const tarch::la::Vector<3,double>& values) {
      _F[0][1] = values[0];
      _F[1][1] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void hu(double v0,double v1,double v2) {
      _F[0][1] = v0;
      _F[1][1] = v1;
      #if DIMENSIONS==3
      _F[2][1] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void hu(double v0,double v1) {
      _F[0][1] = v0;
      _F[1][1] = v1;
    }
    #endif
    // getters for hv
    double hv(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][2];
    }
    tarch::la::Vector<DIMENSIONS,double> hv() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][2],_F[1][2]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][2],_F[1][2],_F[2][2]);
      #endif
      return values;
    }
    // setters for hv
    double& hv(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][2];
    }

    void hv(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][2] = values[0];
      _F[1][2] = values[1];
      #if DIMENSIONS==3
      _F[2][2] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void hv(const tarch::la::Vector<3,double>& values) {
      _F[0][2] = values[0];
      _F[1][2] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void hv(double v0,double v1,double v2) {
      _F[0][2] = v0;
      _F[1][2] = v1;
      #if DIMENSIONS==3
      _F[2][2] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void hv(double v0,double v1) {
      _F[0][2] = v0;
      _F[1][2] = v1;
    }
    #endif
    // getters for b
    double b(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][3];
    }
    tarch::la::Vector<DIMENSIONS,double> b() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][3],_F[1][3]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][3],_F[1][3],_F[2][3]);
      #endif
      return values;
    }
    // setters for b
    double& b(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][3];
    }

    void b(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][3] = values[0];
      _F[1][3] = values[1];
      #if DIMENSIONS==3
      _F[2][3] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void b(const tarch::la::Vector<3,double>& values) {
      _F[0][3] = values[0];
      _F[1][3] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void b(double v0,double v1,double v2) {
      _F[0][3] = v0;
      _F[1][3] = v1;
      #if DIMENSIONS==3
      _F[2][3] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void b(double v0,double v1) {
      _F[0][3] = v0;
      _F[1][3] = v1;
    }
    #endif
}; // end of Fluxes

// NamingSchemes:

//
// Global Observables
//
class SWE::AbstractMySWESolver_FV::ReadOnlyGlobalObservables {
  private:
    const double* const _observables;
  public:
    static constexpr int Size = 0;
    
    ReadOnlyGlobalObservables(const double* const observables) : _observables(observables) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    const double* data() const {
      return _observables;
    }
    
    int size() const {
      return Size;
    }

}; // end of ReadOnlyGlobalObservables


class SWE::AbstractMySWESolver_FV::GlobalObservables {
  private:
    double* const _observables;
  public:
    static constexpr int Size = 0;
  
    GlobalObservables(double* const observables) : _observables(observables) {}
    
    void operator = (GlobalObservables& observables) {
      std::copy(observables.data(),observables.data()+Size,_observables);
    }
    
    void operator = (ReadOnlyGlobalObservables& observables) {
      assertion(observables.size()==Size);
      std::copy(observables.data(),observables.data()+Size,_observables);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    double* data() {
      return _observables;
    }
    
    int size() const {
      return Size;
    }

}; 
// end of GlobalObservables

#endif